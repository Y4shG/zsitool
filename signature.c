/*
 *  Copyright (c) 2016 Tomasz Mo≈Ñ <desowin@gmail.com>
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; under version 3 of the License.
 *
 *  In addition, as a special exception, the copyright holders give
 *  permission to link the code of portions of this program with the
 *  OpenSSL library under certain conditions as described in each
 *  individual source file, and distribute linked combinations including
 *  the two.
 *
 *  You must obey the GNU General Public License in all respects for all
 *  of the code used other than OpenSSL. If you modify file(s) with this
 *  exception, you may extend this exception to your version of the
 *  file(s), but you are not obligated to do so. If you do not wish to do
 *  so, delete this exception statement from your version. If you delete
 *  this exception statement from all source files in the program, then
 *  also delete it here.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses>.
 */

#define _DEFAULT_SOURCE
#define _BSD_SOURCE
#include <endian.h>

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <inttypes.h>
#include <limits.h>
#include <gmp.h>
#include "signature.h"
#include "srr.h"

/* TODO: detect if OpenSSL or libgcrypt should be used */
#if 0
#include <openssl/sha.h>
#else
/* Emulate OpenSSL API using libgcrypt */
#include <gcrypt.h>
#define SHA_DIGEST_LENGTH 20
#define SHA_CTX gcry_md_hd_t
void SHA1_Init(SHA_CTX *ctx)
{
    gcry_md_open(ctx, GCRY_MD_SHA1, 0);
}

void SHA1_Update(SHA_CTX *ctx, const void *data, unsigned long len)
{
    gcry_md_write(*ctx, data, len);
}

void SHA1_Final(unsigned char *md, SHA_CTX *ctx)
{
    gcry_md_final(*ctx);
    memcpy(md, gcry_md_read(*ctx, 0), SHA_DIGEST_LENGTH);
    gcry_md_close(*ctx);
}

void SHA1_Copy(SHA_CTX *dest, SHA_CTX *src)
{
    gcry_error_t err;
    err = gcry_md_copy(dest, *src);
    if (err)
    {
        printf("SHA1 Copy failed: %d\n", err);
        abort();
    }
}

#define SHA256_DIGEST_LENGTH 32
#define SHA256_CTX gcry_md_hd_t
void SHA256_Init(SHA_CTX *ctx)
{
    gcry_md_open(ctx, GCRY_MD_SHA256, 0);
}

void SHA256_Update(SHA_CTX *ctx, const void *data, unsigned long len)
{
    gcry_md_write(*ctx, data, len);
}

void SHA256_Final(unsigned char *md, SHA_CTX *ctx)
{
    gcry_md_final(*ctx);
    memcpy(md, gcry_md_read(*ctx, 0), SHA256_DIGEST_LENGTH);
    gcry_md_close(*ctx);
}
#endif

#define N_ELEMENTS(array) (sizeof(array)/sizeof(array[0]))

/*! RSA public exponent in Big Endian. */
static uint8_t be_exponent[] = { 0x29 };
/*! RSA modulus in Big Endian. */
static uint8_t be_modulus[] =
{
0xb5, 0x3e, 0x28, 0x3a, 0xd7, 0xcd, 0xae, 0x18, 0x85, 0x3a, 0xc5, 0x0c, 0xbc, 0xa4, 0x88, 0xf0,
0x9d, 0x48, 0x0e, 0x4d, 0x33, 0x2e, 0xe5, 0x83, 0xac, 0xa8, 0x27, 0x79, 0x46, 0x86, 0xa5, 0xe5,
0x1b, 0xc7, 0x12, 0xec, 0xea, 0xe1, 0x25, 0x86, 0xfe, 0x0e, 0xf8, 0x49, 0xa3, 0xe0, 0x47, 0x9a,
0x72, 0x46, 0xed, 0x9b, 0x03, 0x0f, 0xc7, 0x19, 0xf5, 0x24, 0x5d, 0x14, 0xff, 0x08, 0xc3, 0x74,
0x95, 0x26, 0x9f, 0x83, 0x8e, 0xe1, 0x57, 0xb9, 0x0e, 0xd9, 0x37, 0x54, 0x8a, 0x54, 0x30, 0x0c,
0x95, 0x24, 0x30, 0x5e, 0xa6, 0x17, 0x68, 0x4f, 0xcf, 0xdb, 0x3b, 0xee, 0x62, 0xeb, 0xa6, 0xac,
0xb0, 0xe2, 0x42, 0x82, 0x75, 0xdd, 0x9e, 0x84, 0xc7, 0x24, 0x1f, 0x8c, 0x7a, 0xe8, 0xec, 0x8e,
0xb2, 0x09, 0x0f, 0x69, 0x65, 0xa4, 0x9e, 0x2b, 0x57, 0x34, 0xa4, 0xd6, 0x71, 0xfd, 0x9b, 0x0e,
0x5e, 0xaf, 0x27, 0xe7, 0x56, 0xce, 0x33, 0xde, 0xfb, 0x75, 0x44, 0x8f, 0x6e, 0xf7, 0x9e, 0xfb,
0xc3, 0x96, 0x68, 0x99, 0x5f, 0xa5, 0x1a, 0xc4, 0x8f, 0x12, 0x6d, 0xfe, 0x52, 0x99, 0x26, 0xd2,
0x00, 0xc8, 0x37, 0x68, 0x2d, 0xb0, 0x73, 0xe3, 0x7e, 0x8a, 0xeb, 0xce, 0xdb, 0x7b, 0xbf, 0xb9,
0xd9, 0xe4, 0x07, 0x92, 0x17, 0x07, 0x48, 0xf5, 0x9b, 0x33, 0xf8, 0x8e, 0xbf, 0x61, 0xa8, 0x22,
0x15, 0x4d, 0x07, 0xcd, 0x89, 0x92, 0x63, 0x19, 0x00, 0xd5, 0x8d, 0x0e, 0x92, 0xee, 0x22, 0xbc,
0x4f, 0x2b, 0x96, 0x10, 0x99, 0xf4, 0xa4, 0x72, 0xf3, 0xd8, 0x03, 0x18, 0x83, 0x04, 0x36, 0x5a,
0x14, 0x87, 0xd6, 0xc6, 0xbb, 0xc4, 0xfe, 0x9c, 0x4d, 0xee, 0x52, 0x2e, 0x6f, 0x0b, 0xe6, 0xda,
0xaa, 0x0c, 0xba, 0xd3, 0xf3, 0xae, 0x76, 0x7c, 0xae, 0xfd, 0x71, 0xed, 0xa9, 0x7d, 0x01, 0xe1
};

static const struct
{
    const uint8_t *hash;
    const int hash_len;
    const uint8_t *sig;
    const int sig_len;
}
known_signatures[] =
{
{ .hash = (const uint8_t[]){0x32, 0x0c, 0x48, 0x5e, 0xb4, 0x28, 0x7f, 0xee, 0x5d, 0x87, 0xb6, 0xfd, 0x79, 0xd7, 0xb5, 0x4e, 0xd6, 0xb2, 0x3f, 0xd4},
  .hash_len = 20,
  .sig = (const uint8_t[]){0x02, 0x4c, 0x53, 0xdb, 0xf4, 0xd6, 0x7b, 0x5e, 0xc8, 0x53, 0xeb, 0x8d, 0x32, 0x5c, 0xc5, 0xc4, 0x11, 0xf7, 0xa3, 0x8a, 0x07, 0x93, 0x55, 0x90, 0x90, 0x95, 0x1d, 0xf3, 0x1f, 0xb8, 0x9d, 0x6d, 0x62, 0x87, 0xdb, 0x3d, 0x39, 0xac, 0x9b, 0x4d, 0x79, 0xe5, 0x12, 0xb5, 0x20, 0x65, 0xb1, 0x93, 0x99, 0x2f, 0xc5, 0x50, 0x9a, 0x9e, 0x54, 0xdd, 0x3c, 0x12, 0x1e, 0x2f, 0x21, 0x92, 0xf4, 0x8d, 0x10, 0xec, 0x79, 0xcf, 0x1c, 0x1e, 0x3f, 0x9b, 0x09, 0xbc, 0xf5, 0x8e, 0xca, 0x61, 0x35, 0x04, 0x92, 0xe1, 0x5f, 0x56, 0x79, 0xcb, 0x0e, 0x10, 0xe2, 0xe3, 0xf0, 0x6e, 0x49, 0xe9, 0xa1, 0x81, 0xf7, 0xdc, 0x04, 0x9f, 0x0f, 0x2a, 0x40, 0xbc, 0x4d, 0x29, 0x0a, 0xce, 0x2a, 0x7d, 0x09, 0x24, 0xc5, 0x03, 0x7b, 0xfc, 0x87, 0xbe, 0xf4, 0xb5, 0xea, 0x0a, 0xd3, 0xaf, 0x83, 0xc6, 0x4b, 0x62, 0xb8, 0x6b, 0xfc, 0x47, 0x94, 0xf5, 0x21, 0xfb, 0x14, 0x73, 0xa1, 0x4d, 0x5a, 0xd3, 0x56, 0x3b, 0x28, 0xf5, 0x2d, 0x29, 0x32, 0x76, 0x3e, 0xa2, 0xad, 0x2e, 0xb8, 0x07, 0xd5, 0x14, 0xef, 0x34, 0x81, 0x48, 0x5e, 0x4d, 0xa0, 0x99, 0x77, 0xc2, 0xb9, 0xa7, 0xbc, 0x1f, 0x0f, 0x74, 0x50, 0x02, 0xfe, 0xdf, 0x8d, 0x89, 0xf3, 0xc9, 0xd2, 0x31, 0x87, 0x65, 0x4c, 0xb7, 0x2d, 0xa5, 0xbe, 0x87, 0x15, 0xe2, 0x6c, 0x0e, 0xed, 0x65, 0xe7, 0x6d, 0x56, 0x28, 0xc7, 0x2a, 0x37, 0xc5, 0x23, 0xd8, 0xa6, 0x95, 0xc4, 0xe0, 0x5c, 0xe3, 0x27, 0xb2, 0x43, 0xf9, 0x42, 0xdb, 0x1f, 0xa2, 0x68, 0x25, 0xd9, 0xb2, 0x33, 0x34, 0x3a, 0x33, 0xef, 0x19, 0xba, 0xaf, 0x1e, 0x27, 0xaf, 0xf7, 0x38, 0xc5, 0x37, 0x54, 0xaf, 0x23, 0xb2, 0x8e, 0x73, 0x38, 0xbc, 0x62, 0x8c, 0x73, 0xc4, 0xb0, 0xc7, 0xe8},
  .sig_len = 256},
{ .hash = (const uint8_t[]){0x2e, 0xb7, 0xd6, 0xa0, 0xe8, 0x37, 0xee, 0xe7, 0x35, 0x12, 0x62, 0xb2, 0xbe, 0xeb, 0x24, 0x74, 0x33, 0x68, 0x3a, 0xc2},
  .hash_len = 20,
  .sig = (const uint8_t[]){0x16, 0xb0, 0x85, 0xcd, 0xe5, 0xfc, 0xe5, 0x85, 0xea, 0xec, 0x3a, 0x21, 0x72, 0xaf, 0x8b, 0x9a, 0x06, 0x5e, 0x3a, 0x41, 0x13, 0x67, 0x94, 0x60, 0xe6, 0x50, 0x12, 0x9b, 0x1c, 0x20, 0x56, 0xea, 0x49, 0x35, 0x43, 0xe1, 0x30, 0xc5, 0x20, 0x42, 0x3f, 0x64, 0x37, 0xb6, 0xdc, 0x3c, 0x80, 0x23, 0xf3, 0x40, 0x9f, 0xf3, 0x49, 0x97, 0x9a, 0x60, 0xd9, 0x88, 0xa6, 0x18, 0x6d, 0x58, 0x6c, 0x77, 0xd6, 0x57, 0xf2, 0x8d, 0xac, 0xb6, 0x97, 0x8f, 0x75, 0x5a, 0x84, 0x00, 0x0a, 0x2e, 0xce, 0xc8, 0x77, 0x7b, 0x37, 0x3b, 0xe4, 0x6e, 0xd5, 0x9f, 0x4a, 0x03, 0x94, 0x0f, 0xad, 0xee, 0x4d, 0x30, 0xcd, 0x15, 0x4a, 0x94, 0x7d, 0xc6, 0x22, 0x8d, 0x60, 0x01, 0xd7, 0xe9, 0x78, 0x5c, 0x95, 0xf7, 0x28, 0x9a, 0x91, 0xfb, 0x5e, 0x0d, 0xb9, 0x83, 0x8f, 0x67, 0x0d, 0x06, 0x4b, 0xb7, 0x72, 0x0b, 0x2b, 0x7c, 0x9f, 0x03, 0x4a, 0x84, 0x46, 0x54, 0x1e, 0x67, 0x72, 0x25, 0x03, 0x88, 0x7b, 0xa1, 0x5d, 0x27, 0xb0, 0x4c, 0x9d, 0x99, 0xb2, 0x15, 0x42, 0x64, 0x50, 0x41, 0x72, 0x97, 0x75, 0x31, 0x76, 0xc1, 0x76, 0xfb, 0xca, 0xb6, 0xc3, 0x4d, 0x99, 0x5b, 0x5b, 0x7d, 0x48, 0x7f, 0xab, 0x46, 0x5b, 0xc4, 0x02, 0x12, 0x13, 0x15, 0xe4, 0x59, 0xb2, 0x50, 0xa2, 0x08, 0x73, 0x09, 0x6c, 0xc4, 0x51, 0xb6, 0x79, 0xa7, 0x88, 0x5c, 0xce, 0x91, 0xcb, 0x9f, 0x16, 0x78, 0x07, 0x31, 0x7b, 0xf5, 0x0d, 0x61, 0x51, 0x37, 0xcc, 0x09, 0x92, 0xa8, 0x9c, 0x27, 0xca, 0x47, 0x96, 0xd9, 0xb2, 0x75, 0x4e, 0x76, 0x65, 0x1d, 0xd2, 0x0c, 0x78, 0x3d, 0xb7, 0xdb, 0x5b, 0xd5, 0x09, 0x64, 0x4d, 0x61, 0x9a, 0x9b, 0x11, 0x8a, 0x55, 0x41, 0x1e, 0xdb, 0x01, 0x2b, 0xe9, 0x7a, 0xa0, 0x4c, 0xd2, 0x27},
  .sig_len = 256},
{ .hash = (const uint8_t[]){0x99, 0xbf, 0xca, 0x6b, 0xa3, 0x92, 0x8a, 0xde, 0xce, 0xe8, 0xf8, 0x4d, 0x6e, 0xfa, 0x64, 0xd5, 0x2d, 0x6e, 0x8c, 0x82},
  .hash_len = 20,
  .sig = (const uint8_t[]){0x09, 0xa8, 0x99, 0x00, 0x60, 0xc6, 0x57, 0x97, 0x1b, 0xbc, 0x77, 0xd2, 0x63, 0xa7, 0x98, 0xa3, 0x11, 0x61, 0x63, 0xa1, 0x73, 0x72, 0xe0, 0x10, 0x04, 0xc1, 0xb9, 0xa4, 0xf5, 0x33, 0xd7, 0x00, 0x2f, 0x1f, 0x3d, 0x0d, 0x2a, 0x84, 0x67, 0x2e, 0xfc, 0x77, 0x14, 0x65, 0x14, 0xde, 0x5d, 0xce, 0x99, 0x09, 0xd3, 0x72, 0x4c, 0xc1, 0x09, 0x9a, 0xe4, 0x5a, 0xa1, 0xe9, 0xea, 0xae, 0xda, 0x4b, 0x06, 0x14, 0xa1, 0xf4, 0x07, 0x51, 0x82, 0x77, 0x63, 0x1f, 0x2d, 0xf1, 0x45, 0x1b, 0x9a, 0x0d, 0x4c, 0xa8, 0x36, 0x44, 0x12, 0xc9, 0xdc, 0xa5, 0x54, 0xe2, 0x46, 0x0b, 0xc6, 0xea, 0x12, 0x9d, 0xf2, 0x68, 0xd7, 0x71, 0xa6, 0x44, 0x57, 0x0a, 0x5a, 0x2b, 0x6e, 0x53, 0x99, 0x0f, 0xec, 0x84, 0xb2, 0xd6, 0x98, 0xd1, 0xc7, 0x16, 0x1a, 0xb0, 0xbe, 0x51, 0x6f, 0x15, 0xd0, 0xf3, 0x8b, 0x63, 0x02, 0x5f, 0x11, 0x2a, 0x48, 0xd8, 0x36, 0x82, 0x90, 0x20, 0x9a, 0xee, 0x1b, 0x40, 0xd3, 0xe8, 0x58, 0xf0, 0xcc, 0x9c, 0x3a, 0xce, 0x2f, 0x41, 0xe0, 0x52, 0x39, 0xf4, 0x4c, 0x2a, 0x31, 0x23, 0xa6, 0x60, 0xa2, 0x48, 0x8e, 0xbe, 0x07, 0x87, 0xa0, 0x77, 0xcd, 0x61, 0x0d, 0x25, 0x6a, 0x8a, 0x11, 0xc2, 0xc3, 0xc5, 0x37, 0xc4, 0x8f, 0xa6, 0xef, 0x62, 0x5e, 0xa8, 0x8f, 0x1a, 0xbf, 0x03, 0xf5, 0xeb, 0xfd, 0xcc, 0x47, 0x18, 0x6b, 0xe9, 0xb9, 0x6c, 0xb9, 0x2a, 0x18, 0x2d, 0x98, 0x21, 0x03, 0x24, 0x44, 0x54, 0xeb, 0x1a, 0xac, 0xfc, 0xe1, 0xcb, 0xfa, 0x04, 0x58, 0xf5, 0x72, 0x1d, 0xf1, 0x62, 0xcf, 0xd1, 0x81, 0xbb, 0x13, 0x0b, 0x3c, 0x5b, 0x2f, 0x84, 0xd0, 0x2a, 0x2d, 0x5f, 0xcb, 0x50, 0x57, 0x24, 0x6a, 0x83, 0xc5, 0xdd, 0x05, 0x1c, 0x20, 0x33, 0x73, 0x75, 0xe2, 0x2a},
  .sig_len = 256},
{ .hash = (const uint8_t[]){0x78, 0x69, 0x4b, 0x0b, 0xb0, 0x2e, 0xf3, 0xb2, 0xa3, 0x0a, 0xb5, 0x95, 0x0e, 0x10, 0xb7, 0xb6, 0x5d, 0x2d, 0x40, 0x93},
  .hash_len = 20,
  .sig = (const uint8_t[]){0x4e, 0x2f, 0x79, 0x38, 0x5e, 0xdc, 0x73, 0x46, 0xdf, 0x3c, 0xa8, 0xd1, 0xa4, 0x04, 0x1a, 0x92, 0x43, 0x1a, 0xce, 0xae, 0x9c, 0xe7, 0x5e, 0xf9, 0x0c, 0xe8, 0xb8, 0x6f, 0xd4, 0x36, 0x75, 0xd9, 0x67, 0xbd, 0x1e, 0x97, 0x43, 0x65, 0x63, 0xc3, 0xdf, 0xef, 0x8a, 0xc5, 0x09, 0x58, 0x4f, 0xf6, 0xb5, 0xe2, 0x32, 0x90, 0x0b, 0x95, 0xe2, 0x18, 0xa8, 0xf0, 0x99, 0xfd, 0xb0, 0x4b, 0x1d, 0x73, 0xbc, 0xd6, 0x46, 0x11, 0xcb, 0x44, 0x13, 0x3d, 0x95, 0x71, 0x26, 0xc4, 0xfa, 0x3f, 0xe9, 0x35, 0xf0, 0xf6, 0xe4, 0x1f, 0xdd, 0x84, 0x16, 0x7e, 0x1e, 0xff, 0xff, 0xd4, 0x5e, 0xf5, 0x79, 0x49, 0x3a, 0xac, 0x83, 0xb8, 0xb7, 0x4a, 0x6d, 0x84, 0xb6, 0x51, 0x63, 0x92, 0x5a, 0x50, 0xf9, 0x59, 0x4e, 0x26, 0x39, 0x8e, 0x25, 0x7b, 0xda, 0x4e, 0x59, 0x61, 0x61, 0x84, 0x84, 0xa9, 0x97, 0x0b, 0xb0, 0x5c, 0x9f, 0x9a, 0x06, 0x44, 0x1d, 0x7c, 0x87, 0x06, 0x9f, 0xcb, 0x3e, 0x33, 0xc4, 0x6c, 0xc3, 0x56, 0xed, 0xab, 0x8a, 0xbd, 0xe4, 0x0b, 0xc4, 0x19, 0x92, 0x9b, 0x59, 0xa1, 0x23, 0xfd, 0xf5, 0x02, 0xb5, 0xd6, 0x90, 0x17, 0x4e, 0x32, 0xff, 0xa9, 0x51, 0xdf, 0xbc, 0xdd, 0x35, 0x42, 0x3b, 0x6e, 0x97, 0xf8, 0xe3, 0x2e, 0x0f, 0x8c, 0x9f, 0xe1, 0x12, 0x2b, 0xac, 0x50, 0x01, 0x64, 0xf9, 0xed, 0x53, 0xdb, 0x09, 0x6f, 0xf7, 0x0d, 0xca, 0x83, 0xf8, 0x04, 0x67, 0xcd, 0x40, 0xe9, 0x4f, 0x89, 0xcb, 0x29, 0x7c, 0xf5, 0xbc, 0xb1, 0xe6, 0x5f, 0xd0, 0xc8, 0x14, 0x0d, 0x01, 0xa8, 0x4e, 0xab, 0x33, 0xfa, 0xfb, 0x9c, 0x47, 0x0b, 0x47, 0x9e, 0x0a, 0xc1, 0x64, 0x8a, 0x89, 0x33, 0xd6, 0xf2, 0xa4, 0x93, 0x1d, 0xd1, 0x06, 0x3a, 0x86, 0x62, 0xf9, 0xf5, 0xc4, 0x65, 0xbb, 0x72},
  .sig_len = 256},
{ .hash = (const uint8_t[]){0x1e, 0xc6, 0xb3, 0x94, 0x3e, 0x60, 0xa6, 0xa5, 0x79, 0xcf, 0x51, 0x9c, 0xc1, 0x8b, 0xdf, 0x7c, 0x88, 0x22, 0x01, 0x1c},
  .hash_len = 20,
  .sig = (const uint8_t[]){0x1b, 0xee, 0x0e, 0xa2, 0xc7, 0xa3, 0x8c, 0x82, 0x47, 0x63, 0x80, 0x9f, 0x73, 0x95, 0x4b, 0xe3, 0xaf, 0xee, 0x13, 0x86, 0xbe, 0x3d, 0x58, 0xe3, 0xb3, 0xc0, 0xfa, 0xe4, 0xf6, 0x4e, 0xeb, 0xcb, 0x92, 0xc9, 0x9d, 0xfb, 0xda, 0xa9, 0x00, 0xb6, 0x68, 0xd2, 0xe8, 0x88, 0x16, 0x1e, 0x6e, 0x6d, 0x5d, 0x39, 0xb7, 0x91, 0xfc, 0xb6, 0x4c, 0x23, 0x86, 0xe3, 0x02, 0x55, 0x26, 0x3f, 0xbc, 0x4a, 0x4f, 0xf5, 0xb3, 0x12, 0xdf, 0xe7, 0xf6, 0x9e, 0x6c, 0xe9, 0xd6, 0xb8, 0x3b, 0xf0, 0x56, 0xb9, 0x08, 0x20, 0xc3, 0x34, 0x07, 0x45, 0x00, 0x2f, 0x85, 0xd0, 0x99, 0xd8, 0x78, 0x47, 0xc0, 0xdf, 0xb7, 0xce, 0x8d, 0x74, 0xa0, 0x8e, 0x6e, 0x68, 0x29, 0x8d, 0xd9, 0x57, 0x8c, 0xd8, 0xfc, 0xbe, 0xe7, 0x2b, 0x1f, 0xc0, 0xc7, 0xcb, 0x84, 0xb5, 0x51, 0x93, 0xb8, 0xbf, 0xb0, 0xdf, 0x50, 0x31, 0xf2, 0x0f, 0x41, 0xc8, 0x67, 0xb4, 0x49, 0x30, 0xff, 0x0c, 0x05, 0xd3, 0x8c, 0x88, 0x7d, 0x92, 0xbe, 0x62, 0x54, 0x59, 0x62, 0x2a, 0x36, 0xb4, 0x7e, 0x4d, 0x8d, 0x8b, 0x97, 0xe8, 0x6c, 0x82, 0xcc, 0x83, 0xef, 0x0f, 0x80, 0x62, 0x9e, 0xae, 0x7c, 0xa8, 0x48, 0xac, 0x19, 0x1b, 0x18, 0x1d, 0xb8, 0x63, 0x0a, 0x5a, 0x33, 0xeb, 0x39, 0x89, 0xab, 0x12, 0x5a, 0x0f, 0x29, 0xb3, 0xd3, 0x94, 0xbf, 0x4c, 0x55, 0x12, 0xed, 0xcd, 0x89, 0x12, 0x64, 0x2e, 0x2b, 0x88, 0xd0, 0xb9, 0xfc, 0x3a, 0xb7, 0x96, 0x63, 0xfc, 0xa4, 0xcb, 0x94, 0x4f, 0x99, 0x3d, 0xad, 0x07, 0x7d, 0xad, 0xd6, 0x16, 0xcb, 0x57, 0x8e, 0x92, 0x35, 0x5a, 0xd2, 0x5a, 0x96, 0x54, 0x42, 0x5b, 0x07, 0x23, 0xc7, 0x90, 0xd0, 0x12, 0xea, 0x3a, 0x2b, 0x5b, 0x8a, 0x32, 0x52, 0x90, 0x0f, 0x30, 0x0d, 0x8b, 0xb1, 0xb9},
  .sig_len = 256},
{ .hash = (const uint8_t[]){0x64, 0x84, 0x41, 0x38, 0xa0, 0x21, 0x21, 0x63, 0xb8, 0xbe, 0xc4, 0x88, 0xf7, 0xcc, 0x2a, 0x65, 0x2c, 0x93, 0xf6, 0xdc},
  .hash_len = 20,
  .sig = (const uint8_t[]){0x21, 0x3b, 0xb8, 0xa4, 0xd5, 0x1b, 0x32, 0xbc, 0xad, 0x40, 0x38, 0xd4, 0x24, 0x96, 0x16, 0x96, 0xa7, 0x2d, 0xb1, 0x59, 0xbb, 0xb2, 0x63, 0x28, 0xfd, 0x2a, 0x49, 0x5e, 0xfc, 0x03, 0x3c, 0x00, 0x8b, 0xfb, 0x07, 0xcb, 0x8b, 0xad, 0x0d, 0xc9, 0xc3, 0x71, 0x41, 0x1a, 0xd2, 0x5f, 0xe4, 0x30, 0xeb, 0xcb, 0x7b, 0xdf, 0x07, 0x63, 0x1a, 0x84, 0xaa, 0x89, 0x6f, 0x1e, 0x95, 0x0a, 0x27, 0xc7, 0xb9, 0x16, 0x33, 0x39, 0x5b, 0xb1, 0x15, 0x9e, 0x4e, 0x27, 0xcf, 0x71, 0x83, 0x15, 0xa4, 0x3a, 0x0b, 0x0c, 0x6a, 0xf3, 0x34, 0x5e, 0xcc, 0xee, 0x6f, 0xe3, 0x09, 0xee, 0x67, 0x49, 0x70, 0xf4, 0xcf, 0x7d, 0x29, 0x67, 0xeb, 0x8e, 0x16, 0x57, 0x91, 0x33, 0x95, 0xcf, 0xcb, 0x4e, 0x55, 0xed, 0x7c, 0x2b, 0xff, 0xa9, 0x50, 0x76, 0x07, 0x2e, 0x9b, 0xb2, 0x50, 0x8e, 0xb0, 0xde, 0xad, 0x9b, 0xc5, 0xb3, 0x67, 0x15, 0x79, 0xc3, 0x48, 0x8f, 0x90, 0xbf, 0x0a, 0x14, 0x35, 0xec, 0xfb, 0x24, 0x1d, 0xe2, 0x6d, 0x02, 0xdd, 0x18, 0x42, 0xf1, 0x5f, 0xc3, 0x85, 0xfa, 0xc1, 0xa5, 0x77, 0x17, 0x91, 0x35, 0x44, 0xf5, 0xf8, 0xcc, 0xda, 0x68, 0x5c, 0xc3, 0x94, 0x4e, 0xf9, 0x72, 0x53, 0xbd, 0x9c, 0x46, 0x12, 0x98, 0x62, 0xb3, 0x35, 0x19, 0x0d, 0x3e, 0x6b, 0x38, 0x4d, 0xda, 0xf8, 0x5d, 0xfb, 0x37, 0x6b, 0xa3, 0xe2, 0xbf, 0x76, 0x5b, 0x06, 0x0e, 0x3f, 0xb4, 0x50, 0x1c, 0x3c, 0x5c, 0xdf, 0x93, 0xe3, 0xbd, 0x94, 0xcc, 0x73, 0x16, 0xc9, 0x5d, 0xcd, 0xe0, 0x12, 0x4e, 0xeb, 0x00, 0x84, 0xd0, 0x2c, 0xf7, 0xc5, 0xa7, 0xe3, 0xcc, 0x61, 0xf5, 0x95, 0xb9, 0xed, 0xd5, 0x95, 0xfe, 0x2b, 0xed, 0xc5, 0x54, 0xd7, 0x2a, 0x41, 0x13, 0x3d, 0x00, 0xba, 0x09, 0xad, 0x6d, 0x80, 0x0a},
  .sig_len = 256},
{ .hash = (const uint8_t[]){0xb8, 0x4d, 0xe2, 0xc4, 0x36, 0x91, 0xd0, 0xa6, 0x03, 0x8a, 0xa0, 0x57, 0x76, 0x5a, 0x11, 0x3f, 0x60, 0xd1, 0x95, 0xb1},
  .hash_len = 20,
  .sig = (const uint8_t[]){0x1d, 0x3f, 0xec, 0x6d, 0xc5, 0xc8, 0x62, 0x94, 0x4f, 0xa2, 0x94, 0x82, 0xc8, 0x35, 0xc5, 0xea, 0xd3, 0xf8, 0x54, 0xb9, 0x17, 0xad, 0x6b, 0xef, 0xbe, 0x9f, 0x70, 0xb4, 0x84, 0x4d, 0xd4, 0x61, 0xb0, 0x5f, 0x8c, 0x79, 0x21, 0x6c, 0x94, 0x38, 0x0e, 0x29, 0x7f, 0x7d, 0x70, 0x16, 0x7f, 0xe8, 0x6d, 0x3a, 0xef, 0x06, 0x22, 0x4c, 0xbc, 0xd6, 0x9b, 0x78, 0x40, 0x2a, 0x0e, 0xd8, 0xde, 0xba, 0xf2, 0x27, 0x85, 0x44, 0xfe, 0x13, 0x25, 0xf2, 0x07, 0xf1, 0x76, 0xd8, 0x31, 0x29, 0xc2, 0x24, 0xcf, 0xd5, 0x81, 0x5a, 0x97, 0x86, 0x18, 0xf3, 0xb0, 0x13, 0x7f, 0x4f, 0xcb, 0xfd, 0xdd, 0xb8, 0x6f, 0x6d, 0x1d, 0x62, 0xc0, 0x0d, 0x50, 0x7e, 0x5a, 0xfa, 0xdf, 0xbe, 0xce, 0x9b, 0x5a, 0x59, 0xe6, 0x93, 0x08, 0x7c, 0x8b, 0x0e, 0xe4, 0xc2, 0xf9, 0xff, 0xac, 0x7e, 0xd5, 0x0a, 0x27, 0xef, 0x61, 0x78, 0x08, 0x89, 0xa3, 0x4e, 0x7d, 0x54, 0xc7, 0xb3, 0xe8, 0xff, 0x55, 0x4d, 0xab, 0x77, 0x1a, 0xf7, 0xd0, 0xf6, 0x27, 0xc1, 0xdb, 0x9a, 0xb2, 0x34, 0xec, 0xd9, 0xae, 0x40, 0xab, 0x21, 0x97, 0x5d, 0x20, 0x0e, 0xb6, 0x33, 0x21, 0x3f, 0x48, 0x58, 0xe6, 0x66, 0xc5, 0xff, 0x4f, 0x89, 0xea, 0x45, 0x6f, 0x63, 0xee, 0x53, 0x6c, 0x65, 0xaf, 0xe2, 0x08, 0x96, 0xe9, 0xdf, 0xa4, 0x40, 0x52, 0x6e, 0x45, 0x58, 0x60, 0x90, 0x2a, 0xff, 0xb9, 0x65, 0x55, 0x58, 0x4b, 0x1a, 0x4c, 0x8c, 0x27, 0xc5, 0xbd, 0xfd, 0x03, 0x7d, 0xe6, 0xe2, 0xeb, 0xb0, 0xe3, 0x26, 0x4a, 0x41, 0xfd, 0xa9, 0x87, 0x68, 0xa9, 0x4a, 0x36, 0x2b, 0x51, 0x4f, 0x49, 0x18, 0x16, 0x6a, 0x60, 0x03, 0x97, 0xc5, 0x29, 0x92, 0x18, 0x83, 0x88, 0x19, 0x1e, 0xc8, 0x2e, 0x7b, 0x91, 0x0d, 0x85, 0x86, 0xf5, 0x1f},
  .sig_len = 256},
{ .hash = (const uint8_t[]){0x41, 0xfd, 0x10, 0x1d, 0xa1, 0x29, 0xdb, 0x7e, 0x70, 0xed, 0x15, 0xe7, 0x77, 0xb6, 0xcc, 0x2f, 0xe5, 0x30, 0xec, 0x3f},
  .hash_len = 20,
  .sig = (const uint8_t[]){0x62, 0x2e, 0xa0, 0x15, 0xf3, 0xeb, 0xc8, 0xe4, 0xdf, 0xdc, 0xd6, 0x05, 0x43, 0xa9, 0x8f, 0x2a, 0xbb, 0x84, 0xa8, 0x93, 0xf1, 0xff, 0xb2, 0x75, 0x69, 0x62, 0x09, 0xb3, 0x53, 0x6a, 0xab, 0x77, 0xb2, 0xad, 0xed, 0xee, 0x31, 0xd8, 0xcc, 0x04, 0x2e, 0xd0, 0xcf, 0xdd, 0x61, 0x31, 0x93, 0x7d, 0xa0, 0x56, 0x32, 0xa8, 0x1e, 0xa4, 0x98, 0x6f, 0xfb, 0x27, 0x02, 0xa4, 0x0d, 0x75, 0x90, 0x33, 0xc3, 0x40, 0xf7, 0x0d, 0x3c, 0xc7, 0x07, 0x7e, 0x26, 0xfc, 0x28, 0x2f, 0xb1, 0x16, 0xcc, 0x0a, 0x11, 0xcf, 0x6b, 0x68, 0xf7, 0xb1, 0xf4, 0xdb, 0xc7, 0x79, 0x57, 0xe7, 0x76, 0xfa, 0x78, 0xe1, 0xab, 0xa6, 0x76, 0xa0, 0x31, 0x66, 0xca, 0xac, 0x36, 0xab, 0x40, 0x39, 0xe4, 0xf5, 0x98, 0xda, 0xb8, 0xc3, 0xe8, 0x41, 0x0b, 0xf1, 0xd9, 0xbf, 0x66, 0x05, 0x95, 0xde, 0x6e, 0x80, 0xda, 0x6f, 0xc6, 0x2c, 0xba, 0x45, 0x39, 0x68, 0xef, 0x33, 0x0a, 0x94, 0x0e, 0x7b, 0xdf, 0xa6, 0xb7, 0xa2, 0x4e, 0x5e, 0xad, 0x7c, 0x41, 0x67, 0x3d, 0xee, 0x62, 0x54, 0x46, 0x5d, 0xa1, 0x45, 0xd2, 0x8c, 0xf1, 0xbc, 0x3a, 0xee, 0x87, 0x92, 0x11, 0xcd, 0x7d, 0x16, 0xf6, 0x91, 0xa2, 0x7b, 0xef, 0x3e, 0xc3, 0xbc, 0x3f, 0x82, 0x34, 0x6f, 0x78, 0x78, 0xdb, 0x73, 0x6e, 0x7b, 0xa5, 0xbf, 0x98, 0x27, 0x25, 0x0c, 0x6f, 0xd0, 0xba, 0x94, 0x5a, 0xb4, 0x51, 0x5c, 0xe7, 0xcb, 0xdc, 0xdd, 0xc9, 0xec, 0x59, 0xa1, 0x45, 0x81, 0x17, 0xd6, 0x48, 0xa4, 0x3d, 0x6e, 0x0e, 0x59, 0x2d, 0x65, 0x09, 0x9e, 0x51, 0xe5, 0xec, 0x67, 0xd1, 0xc7, 0xb6, 0xa0, 0xed, 0x54, 0x38, 0x8e, 0x46, 0x64, 0x33, 0x27, 0xd3, 0x1c, 0x6a, 0xd3, 0x82, 0xd1, 0x0d, 0x88, 0x77, 0xe4, 0xc6, 0x02, 0xbd, 0x81, 0x11, 0xd4},
  .sig_len = 256},
};

static const int n_known_signatures = N_ELEMENTS(known_signatures);

static int has_known_sig(uint8_t *hash, int hash_len)
{
    int i;
    for (i = 0; i < n_known_signatures; i++)
    {
        if ((known_signatures[i].hash_len == hash_len) &&
            (memcmp(hash, known_signatures[i].hash, hash_len) == 0))
        {
            return i;
        }
    }
    return -1;
}

/* Signature is last 2048 bytes of srr_file_data */
#define SRR_SIG_SIZE                                     2048
#define SRR_HEADER_SIZE                                    16

#define RFC4880_SIGNATURE_PACKET_TYPE                       2
#define RFC4880_PACKET_LENGTH_TYPE_MASK                  0x03
#define RFC4880_SIGNATURE_TYPE_BINARY_DOCUMENT           0x00
#define RFC4880_PUBLIC_KEY_ALGORITHM_RSA_ENCRYPT_OR_SIGN 0x01

typedef enum
{
    E_RFC4880_HASH_SHA1 = 2,
    E_RFC4880_HASH_SHA256 = 8,
}
E_RFC4880_Hash;

/**
 * \brief Parses signature in a similar fashion to Sansa Connect bootloader.
 *
 * \param[in] signature Pointer to signature block within SRR file.
 * \param[out] sig_type_ptr Place to store pointer to data that needs to be
 *                          concatenated with actual data before hashing.
 * \param[out] hash_type Place to store hash method used.
 * \param[out] RSA_m_pow_d_mod_n GMP integer to store RSA encrypted message,
 *                               which is pow(m, d) mod n.
 *
 * \return true if Sansa Connect bootloader would accept such signature.
 *              However the firmware check might still fail, because
 *              this does not mean that the RSA signature is valid!
 * \return false if Sansa Connect bootloader would fail firmware without
 *              even performing RSA check.
 */
static bool parse_rfc4880_signature(const uint8_t *signature,
                                    const uint8_t **sig_type_ptr,
                                    E_RFC4880_Hash *hash_type,
                                    mpz_t RSA_m_pow_d_mod_n)
{
    uint8_t PTag;
    const uint8_t *mpi_data;
    int mpi_length;
    int hdr_len;

    PTag = signature[0];
    if (!((PTag & 0x80) /* Bit 7 must be always set */ &&
          !(PTag & 0x40) /* Only old packet format is allowed */ &&
          ((PTag & 0x3C) == (RFC4880_SIGNATURE_PACKET_TYPE << 2))))
    {
        return false;
    }

    switch (PTag & RFC4880_PACKET_LENGTH_TYPE_MASK)
    {
        case 0:
            /* Header is 2 bytes long (PTag + 1 byte length) */
            hdr_len = 2;
            break;
        case 1:
            /* Header is 3 bytes long (PTag + 2 byte length) */
            hdr_len = 3;
            break;
        case 2:
            /* Header is 5 bytes long (PTag + 4 byte length) */
            hdr_len = 5;
            break;
        default:
            /* Header is 1 bytes long and packet is of indeterminate length.
             * Sansa Connect bootloader rejects such packets.
             */
            return false;
    }

    if (signature[hdr_len] != 3)
    {
        /* Sansa Connect bootloader supports only Signatures version 3 */
        return false;
    }

    if (signature[hdr_len + 1] != 5)
    {
        /* This number must be 5 according to RFC4880.
         * Sansa Connect bootloader fails if it is different than 5.
         */
        return false;
    }

    /* Return pointer to:
     *   One-octet signature type.
     *   Four-octet creation time.
     * This 5 bytes must be concatenated with the data to be signed.
     */
    *sig_type_ptr = &signature[hdr_len + 2];

    /* Sansa Connect bootloader supports only signatures of binary documents. */
    if (signature[hdr_len + 2] != RFC4880_SIGNATURE_TYPE_BINARY_DOCUMENT)
    {
        return false;
    }

    /* Bootloader ignores Eight-octet Key ID of signer. */

    /* Public Key Algorithm Must be RSA (Encrypt or Sign). */
    if (signature[hdr_len + 15] != RFC4880_PUBLIC_KEY_ALGORITHM_RSA_ENCRYPT_OR_SIGN)
    {
        return false;
    }

    /* Bootloader supports only SHA1 and SHA256. */
    *hash_type = (E_RFC4880_Hash)signature[hdr_len + 16];
    if ((*hash_type != E_RFC4880_HASH_SHA1) && (*hash_type != E_RFC4880_HASH_SHA256))
    {
        return false;
    }

    /* Bootloader ignores Two-octet field holding left 16 bits of signed hash value. */

    /* MPI comprising the signature (RSA signature value m**d mod n).
     *
     * Note: Bootloader does not check MPI length.
     */
    mpi_length = ((signature[hdr_len + 20] | ((int)signature[hdr_len + 19] << 8)) + 7) / 8;
    mpi_data = &signature[hdr_len + 21];

    /* Fail if MPI extends beyound SRR signature allocated space.
     * Sansa Connect bootloader is perfectly fine with that.
     * However only 2048 bytes of signature can be transferred/programmed.
     */
    if (mpi_length + hdr_len + 21 > SRR_SIG_SIZE)
    {
        return false;
    }

    mpz_import(RSA_m_pow_d_mod_n, mpi_length, 1, 1, 1, 0, mpi_data);
    return true;
}

/**
 * \brief Validates SRR signature.
 *
 * \param srr_file_data SRR file contents.
 * \param srr_file_length @a srr_file_data length in bytes.
 * \param verbose true if function should print srr file information.
 *
 * \return true if @a srr_file_data is valid.
 * \return false if @a srr_file_data is not valid.
 */
static bool validate_srr_signature(const uint8_t *srr_file_data, int srr_file_length,
                                   bool verbose)
{
    mpz_t RSA_encrypted, RSAe, RSAn, RSA_decrypted;
    mpz_t data_hash, sig_hash;
    bool result = false;
    const uint8_t *rfc4880_hashed_data = NULL;
    E_RFC4880_Hash hash_type;
    unsigned char md[SHA256_DIGEST_LENGTH];
    int hash_len;

    mpz_init(RSA_encrypted);
    mpz_init(RSAe);
    mpz_init(RSAn);
    mpz_init(RSA_decrypted);
    mpz_init(data_hash);
    mpz_init(sig_hash);

    if (srr_file_length < SRR_SIG_SIZE + SRR_HEADER_SIZE)
    {
        if (verbose)
        {
            printf("File is too small to be .srr file\n");
        }
        goto exit;
    }

    if (!parse_rfc4880_signature(&srr_file_data[srr_file_length-SRR_SIG_SIZE],
                                 &rfc4880_hashed_data, &hash_type, RSA_encrypted))
    {
        if (verbose)
        {
            printf("Invalid signature packet!\n");
        }
        goto exit;
    }

    if (hash_type == E_RFC4880_HASH_SHA1)
    {
        int i;
        SHA_CTX ctx;
        SHA1_Init(&ctx);
        SHA1_Update(&ctx, srr_file_data, srr_file_length - SRR_SIG_SIZE);
        SHA1_Update(&ctx, rfc4880_hashed_data, 5);
        SHA1_Final(md, &ctx);

        printf("SHA1 Hash: ");
        for (i = 0; i < SHA_DIGEST_LENGTH; i++)
        {
            printf("%02x", md[i]);
        }
        printf("\n");
        hash_len = SHA_DIGEST_LENGTH;
        mpz_import(data_hash, hash_len, 1, 1, 1, 0, &md[0]);
    }
    else if (hash_type == E_RFC4880_HASH_SHA256)
    {
        int i;
        SHA256_CTX ctx;
        SHA256_Init(&ctx);
        SHA256_Update(&ctx, srr_file_data, srr_file_length - SRR_SIG_SIZE);
        SHA256_Update(&ctx, rfc4880_hashed_data, 5);
        SHA256_Final(md, &ctx);

        printf("SHA256 Hash: ");
        for (i = 0; i < SHA256_DIGEST_LENGTH; i++)
        {
            printf("%02x", md[i]);
        }
        printf("\n");
        hash_len = SHA256_DIGEST_LENGTH;
        mpz_import(data_hash, hash_len, 1, 1, 1, 0, &md[0]);
    }
    else
    {
        if (verbose)
        {
            printf("Unsupported Hash type!\n");
        }
        goto exit;
    }

    /* Load modulus and exponents. */
    mpz_import(RSAe, N_ELEMENTS(be_exponent), 1, 1, 1, 0, be_exponent);
    mpz_import(RSAn, N_ELEMENTS(be_modulus), 1, 1, 1, 0, be_modulus);

    /* Perform RSA. Side channel attacks are not an issue for zsitool. */
    mpz_powm(RSA_decrypted, RSA_encrypted, RSAe, RSAn);

    printf("Signature: 0x");
    mpz_out_str(stdout, 16, RSA_decrypted);
    printf("\n");

    /* Sansa Connect bootloader only checks hash_len least significant bytes.
     * Do the same here so if you can forge signature that this function will
     * accept it will be also accepted by bootloader.
     */
    mpz_tdiv_r_2exp(sig_hash, RSA_decrypted, hash_len * 8);
    if (mpz_cmp(sig_hash, data_hash) == 0)
    {
        printf("Valid signature\n");
        if ((hash_type == E_RFC4880_HASH_SHA1) && (has_known_sig(md, hash_len) < 0))
        {
            int i;
            size_t sig_len;
            unsigned char *sig_data = mpz_export(NULL, &sig_len, 1, 1, 1, 0, RSA_encrypted);
            void (*freefunc) (void *, size_t);
            mp_get_memory_functions(NULL, NULL, &freefunc);

            printf("Please consider submitting this signature to zsitool\n");
            printf("{ .hash = (const uint8_t[]){0x%02x", md[0]);
            for (i = 1; i < hash_len; i++)
            {
                printf(", 0x%02x", md[i]);
            }
            printf("},\n  .hash_len = %d,\n", hash_len);
            printf("  .sig = (const uint8_t[]){0x%02x", sig_data[0]);
            for (i = 1; i < sig_len; i++)
            {
                printf(", 0x%02x", sig_data[i]);
            }
            printf("}, \n  .sig_len = %zu},\n", sig_len);
            freefunc(sig_data, sig_len);
        }
    }
    else
    {
        printf("Invalid signature\n");
    }

    result = true;

exit:
    mpz_clear(RSA_encrypted);
    mpz_clear(RSAe);
    mpz_clear(RSAn);
    mpz_clear(RSA_decrypted);
    mpz_clear(data_hash);
    mpz_clear(sig_hash);
    return result;
}

/**
 * \brief Prints SRR file info.
 *
 * \param srr_file_data SRR file contents.
 * \param srr_file_length @a srr_file_data length in bytes.
 *
 * \return true if @a srr_file_data is valid.
 * \return false if @a srr_file_data is not valid.
 */
bool print_srr_file_info(const uint8_t *srr_file_data, int srr_file_length)
{
    SRR_Header *header = (SRR_Header*)&srr_file_data[0];
    uint32_t file_length = 0;
    if (srr_file_length < SRR_HEADER_SIZE)
    {
        printf("SRR file too small!\n");
        return false;
    }

    if (!print_srr_header(header))
    {
        printf("Invalid SRR file header!\n");
        return false;
    }

    file_length = le32toh(header->le_file_length);

    if (file_length + SRR_HEADER_SIZE != (uint32_t)srr_file_length)
    {
        printf("Length in SRR header does not match file size (%d)!\n",
               srr_file_length);
    }
    return validate_srr_signature(srr_file_data, srr_file_length, true);
}

#define FORGE_BITS (SHA_DIGEST_LENGTH*8)

struct forge_workshop
{
    int forge_bits;
    unsigned long int e;   /* RSA Public Exponent in unsigned long int */
    mpz_t RSAe;            /* RSA Public Exponent */
    mpz_t RSAn;            /* RSA modulus */
    mpz_t forge_modulo;    /* Forge modulus = (2 ** forge_bits) */
    mpz_t RSAe_inverse;    /* Modular multiplicative inverse of e under modulo phi(2 ** forge_bits) */
    mpz_t reduced_inverse; /* Temporary RSAe_inverse if problem was reduced by n*e bits */
    mpz_t reduced_modulo;  /* Temporary forge_modulo if problem was reduced by n*e bits */
    mpz_t tmp;             /* Temporary value */
    mpz_t tmp2;            /* Temporary value 2 */
};

static void forge_workshop_free(struct forge_workshop *workshop)
{
    mpz_clear(workshop->RSAe);
    mpz_clear(workshop->RSAn);
    mpz_clear(workshop->forge_modulo);
    mpz_clear(workshop->RSAe_inverse);
    mpz_clear(workshop->reduced_inverse);
    mpz_clear(workshop->reduced_modulo);
    mpz_clear(workshop->tmp);
    mpz_clear(workshop->tmp2);
    memset(workshop, 0, sizeof(struct forge_workshop));
}

static bool forge_workshop_init(struct forge_workshop *workshop)
{
    workshop->forge_bits = (SHA_DIGEST_LENGTH * 8);

    mpz_init(workshop->RSAe);
    mpz_init(workshop->RSAn);
    mpz_init(workshop->forge_modulo);
    mpz_init(workshop->RSAe_inverse);
    mpz_init(workshop->reduced_inverse);
    mpz_init(workshop->reduced_modulo);
    mpz_init(workshop->tmp);
    mpz_init(workshop->tmp2);
    mpz_import(workshop->RSAe, N_ELEMENTS(be_exponent), 1, 1, 1, 0, be_exponent);
    if (!mpz_fits_ulong_p(workshop->RSAe))
    {
        fprintf(stderr, "Unable to forge for such exponent\n");
        forge_workshop_free(workshop);
        return false;
    }
    workshop->e = mpz_get_ui(workshop->RSAe);
    mpz_import(workshop->RSAn, N_ELEMENTS(be_modulus), 1, 1, 1, 0, be_modulus);
    mpz_ui_pow_ui(workshop->forge_modulo, 2, workshop->forge_bits);

    /* Calculate RSAe_inverse.
     * 1. Calculate phi(2 ** forge_bits) = 2 ** (forge_bits-1).
     * 2. Calculate modular multiplicative inverse of RSAe modulo phi(2 ** forge_bits).
     */
    mpz_ui_pow_ui(workshop->tmp, 2, workshop->forge_bits - 1);
    if (!mpz_invert(workshop->RSAe_inverse, workshop->RSAe, workshop->tmp))
    {
        fprintf(stderr, "Unable to find RSAe modulular inverse\n");
        forge_workshop_free(workshop);
        return false;
    }

    return true;
}

static bool forge_signature_mod_inv(mpz_t forged, mpz_t hash, struct forge_workshop *workshop)
{
    int zero_bits;
    int reduced_bits;

    if (mpz_cmp(workshop->forge_modulo, hash) <= 0)
    {
        fprintf(stderr, "Invalid input hash to forge_signature_mod_inv()!\n");
        abort();
        return false;
    }

    if (mpz_cmp_ui(hash, 0) == 0)
    {
        /* Trivial case, forged value is also zero. */
        mpz_set_ui(forged, 0);
        return true;
    }

    /* Count number of least significant zero bits. */
    zero_bits = 0;
    while ((zero_bits < workshop->forge_bits) && (mpz_tstbit(hash, zero_bits) == 0))
    {
        zero_bits++;
    }

    if (zero_bits % workshop->e)
    {
        /* ((forged ** RSAe) modulo workshop->forge_modulo = hash) does not exist. */
        //printf("not exist\n");
        return false;
    }
    reduced_bits = zero_bits / workshop->e;
    if (reduced_bits)
    {
       /* Calculate reduced_inverse.
        * 1. Calculate phi(2 ** (forge_bits - zero_bits)) = 2 ** (forge_bits - zero_bits - 1).
        * 2. Calculate modular multiplicative inverse of RSAe modulo phi(2 ** forge_bits - zero_bits - 1).
        */
       mpz_ui_pow_ui(workshop->tmp, 2, workshop->forge_bits - zero_bits - 1);
       if (!mpz_invert(workshop->reduced_inverse, workshop->RSAe, workshop->tmp))
       {
           /* This won't happen because gcd(RSAe, workshop->tmp) = 1. */
           fprintf(stderr, "Unable to find RSAe modulular inverse (zero bits %d)\n", zero_bits);
           return false;
       }
       mpz_ui_pow_ui(workshop->reduced_modulo, 2, workshop->forge_bits - zero_bits);

       /* 1. Reduce hash by (2 ** zero_bits).
        * 2. Forge signature modulo reduced_modulo.
        * 3. Multiply forged signature by (2 ** reduced_bits).
        *
        * Note: this works because ((2 ** reduced_bits) ** RSAe) = (2 ** zero_bits).
        */
       mpz_tdiv_q_2exp(workshop->tmp, hash, zero_bits);
       mpz_powm(workshop->tmp2, workshop->tmp, workshop->reduced_inverse, workshop->reduced_modulo);

       mpz_mul_2exp(forged, workshop->tmp2, reduced_bits);
    }
    else
    {
        /* Forge signature. */
        mpz_powm(forged, hash, workshop->RSAe_inverse, workshop->forge_modulo);
    }

    /* We have forged signature modulo forge_modulo.
     * However, there is very low probability that it will also work modulo RSAn.
     */
    return true;
}

static bool verify_forged_signature(mpz_t forged, mpz_t hash, struct forge_workshop *workshop)
{
    /* Forged signature modulo RSAn. */
    mpz_powm(workshop->tmp, forged, workshop->RSAe, workshop->RSAn);
    mpz_tdiv_r_2exp(workshop->tmp2, workshop->tmp, workshop->forge_bits);
    if (mpz_cmp(workshop->tmp2, hash) == 0)
    {
        /* Successfully forged and forged value works also under modulo RSAn */
        return true;
    }
    return false;
}

bool forge_signature(const uint8_t *srr_file_data, int srr_file_length)
{
    SRR_Header *header;
    uint32_t file_length;
    SHA_CTX base_ctx, ctx;
    unsigned char md[SHA_DIGEST_LENGTH];
    const uint8_t zero = 0;
    uint32_t ctime;
    struct forge_workshop workshop;
    mpz_t hash, forged;
    int i;
    bool success = false;

    header = (SRR_Header*)&srr_file_data[0];
    if (srr_file_length < SRR_HEADER_SIZE)
    {
        printf("SRR file too small!\n");
        return false;
    }

    if (!print_srr_header(header))
    {
        printf("Invalid SRR file header!\n");
        return false;
    }

    file_length = le32toh(header->le_file_length);

    if (file_length + SRR_HEADER_SIZE != (uint32_t)srr_file_length)
    {
        printf("Length in SRR header does not match file size (%d)!\n",
               srr_file_length);
    }

    mpz_init(hash);
    mpz_init(forged);
    forge_workshop_init(&workshop);

    /* Calculate SHA1 of base (only thing missing is ctime) */
    SHA1_Init(&base_ctx);
    SHA1_Update(&base_ctx, &srr_file_data[0], srr_file_length - SRR_SIG_SIZE);
    SHA1_Update(&base_ctx, &zero, 1);

    ctime = 0;
    do
    {
        SHA1_Copy(&ctx, &base_ctx);
        SHA1_Update(&ctx, &ctime, 4);
        SHA1_Final(md, &ctx);

        i = has_known_sig(&md[0], SHA_DIGEST_LENGTH);
        if ((i >= 0) && (i < n_known_signatures))
        {
            printf("Forgery successful!\n");
            printf("ctime: 0x%08x sig: 0x", ctime);
            mpz_import(forged, known_signatures[i].sig_len, 1, 1, 1, 0, known_signatures[i].sig);
            mpz_out_str(stdout, 16, forged);
            printf("\n");
            success = true;
            break;
        }

        mpz_import(hash, SHA_DIGEST_LENGTH, 1, 1, 1, 0, md);

        if (forge_signature_mod_inv(forged, hash, &workshop) &&
            verify_forged_signature(forged, hash, &workshop))
        {
            printf("Forgery successful!\n");
            printf("ctime: 0x%08x sig: 0x", ctime);
            mpz_out_str(stdout, 16, forged);
            printf("\n");
            success = true;
            break;
        }

        if ((ctime % 0x00100000) == 0)
        {
            printf("ctime 0x%08x\n", ctime);
        }
        ctime++;
    }
    while (ctime != 0);

    if (!success)
    {
        printf("Forgery failed\n");
    }

    mpz_clear(hash);
    mpz_clear(forged);
    forge_workshop_free(&workshop);

    return success;
}

/* Tests forge_signature_mod_inv() against (2 ** 32) + (2 ** 24) values.
 * These values are guaranteed to be forgable with (forged ** RSAe) < RSAn.
 * This test takes quite some time to finish but gives a fairly good
 * confirmation that forge_signature_mod_inv() is working as expected.
 */
void test_forge_signature_mod_inv(void)
{
    mpz_t hash, forged;
    mpz_t limit;
    struct forge_workshop workshop;
    unsigned long int i, max_i;

    mpz_init(hash);
    mpz_init(forged);
    mpz_init(limit);
    forge_workshop_init(&workshop);

    mpz_root(limit, workshop.RSAn, workshop.e);

    if (!mpz_fits_ulong_p(limit))
    {
        fprintf(stderr, "Checking up to maximum unsigned long int.\n");
        max_i = ULONG_MAX;
    }
    else
    {
        fprintf(stderr, "Checking up to 0x");
        mpz_out_str(stdout, 16, limit);
        printf("\n");
        max_i = mpz_get_ui(limit);
    }

    /* Check forged signatures in range [0; 0xFFFFFFFF) */
    for (i = 0; i < 0xFFFFFFFF; i++)
    {
        /* hash = (i ** e) mod (2 ** forge_bits) */
        mpz_ui_pow_ui(workshop.tmp, i, workshop.e);
        mpz_tdiv_r_2exp(hash, workshop.tmp, workshop.forge_bits);
        if (!forge_signature_mod_inv(forged, hash, &workshop))
        {
            fprintf(stderr, "Failed to forge (%lu ** RSAe)\n", i);
        }
        else if (!verify_forged_signature(forged, hash, &workshop))
        {
            fprintf(stderr, "Bug in forgery (%lu ** RSAe)\n", i);
        }
        /* Notify user that computation is ongoing. */
        if ((i % 0x100000) == 0)
        {
            printf("Tested up to 0x%jx\n", i);
        }
    }

    printf("Skipping a lot of values...\n");

    /* Check forged signatures in range [max_i - 0xFFFFFF; max_i) */
    for (i = max_i - 0xFFFFFF; i < max_i; i++)
    {
        /* hash = (i ** e) mod (2 ** forge_bits) */
        mpz_ui_pow_ui(workshop.tmp, i, workshop.e);
        mpz_tdiv_r_2exp(hash, workshop.tmp, workshop.forge_bits);
        if (!forge_signature_mod_inv(forged, hash, &workshop))
        {
            fprintf(stderr, "Failed to forge (%lu ** RSAe)\n", i);
        }
        else if (!verify_forged_signature(forged, hash, &workshop))
        {
            fprintf(stderr, "Bug in forgery (%lu ** RSAe)\n", i);
        }
        /* Notify user that computation is ongoing. */
        if ((i % 0x100000) == 0)
        {
            printf("Tested up to 0x%jx\n", i);
        }
    }
    printf("Test finished\n");

    mpz_clear(hash);
    mpz_clear(forged);
    mpz_clear(limit);
    forge_workshop_free(&workshop);
}

void test_validate_known_signatures(void)
{
    mpz_t RSAe, RSAn, RSA_decrypted, RSA_encrypted, sig_hash, data_hash;
    int i;

    mpz_init(RSAe);
    mpz_init(RSAn);
    mpz_init(RSA_decrypted);
    mpz_init(RSA_encrypted);
    mpz_init(sig_hash);
    mpz_init(data_hash);

    /* Load modulus and exponents. */
    mpz_import(RSAe, N_ELEMENTS(be_exponent), 1, 1, 1, 0, be_exponent);
    mpz_import(RSAn, N_ELEMENTS(be_modulus), 1, 1, 1, 0, be_modulus);

    for (i = 0; i < n_known_signatures; i++)
    {
        int hash_len = known_signatures[i].hash_len;
        mpz_import(data_hash, hash_len, 1, 1, 1, 0, known_signatures[i].hash);
        mpz_import(RSA_encrypted, known_signatures[i].sig_len, 1, 1, 1, 0, known_signatures[i].sig);

        /* Perform RSA. Side channel attacks are not an issue for zsitool. */
        mpz_powm(RSA_decrypted, RSA_encrypted, RSAe, RSAn);

        mpz_tdiv_r_2exp(sig_hash, RSA_decrypted, hash_len * 8);
        if (mpz_cmp(sig_hash, data_hash) == 0)
        {
            printf("Hash/Sig pair %d is valid\n", i);
        }
        else
        {
            printf("Hash/Sig pair %d is invalid\n", i);
        }
    }

    mpz_clear(RSAe);
    mpz_clear(RSAn);
    mpz_clear(RSA_decrypted);
    mpz_clear(RSA_encrypted);
    mpz_clear(sig_hash);
    mpz_clear(data_hash);
}
