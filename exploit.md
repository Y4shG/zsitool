SanDisk Sansa Connect Arbitrary Code Execution
----------------------------------------------

Vulnerability discovered, exploited and documented by Tomasz Mo≈Ñ <desowin@gmail.com>

Introduction
------------

SanDisk Sansa Connect is a digital audio player with 802.11b WiFi functionality. The original firmware is based on Linux.
While the sources for GPL software used in the product have been published, only signed binaries can run on the device.
Official firmware images include RFC4880 signatures generated using 2048-bit RSA key.

The signature check implementation has two bugs:
  * The padding is not being checked
  * The signature multiprecision integer (MPI) length is not being validated

It is not feasible to do n-th root signature forgery attack because the public key exponent value is 41 and only
SHA1 (160 bits) and SHA2 (256 bits) hashes are accepted.

The MPI loading bug can be used to execute arbitrary code supplied by the attacker.

Firmware Recovery
-----------------

It is possible to enter Recovery Mode by holding the right and volume up buttons when powering up the device.
The firmware is loaded to device via USB connection using vendor specific protocol (implemented in `zsitool`).

The firmware consists of two images: kernel and initrd. Both can be loaded to any location in RAM as long as:
  * it does not overlap bootloader code and variables (`0x01300180` to `0x0131E8C7`)
  * it does not overlap stack (`0x01420000` to `0x0143FFFF`)
  * it fits completely in the RAM (`0x01000000` to `0x04FFFFFF`)

The location and size is specified in recovery file header. This makes it possible for an attacker to load
supplied data to two almost freely choosen RAM locations. After loading, but before the signature is verified,
the files are flashed to NOR flash. The NOR flash memory layout is fixed. Kernel range is from `0x00120000` to `0x0031FFFF`,
and initrd range is from `0x00320000` to `0x004FFFFF`.

MPI loading bug
---------------

Bootloader handles bignum arithmetic using fixed size `bignum_t` structure (actual names are not known as the code was
reverse engineered using Ghidra). The `bignum_load()` function does not sanitize input data size.
The function can be written in C as:

```c
typedef struct bignum_t
{
    uint32_t le_words[132];
    uint32_t words_counter;
    uint32_t negative;
} bignum_t;

void bignum_load(bignum_t *out, uint8_t *be_input, int be_input_length)
{
    memset(out, 0, sizeof(bignum_t));
    while (be_input_length > 0)
    {
        /* Shift left parameters: input, number of bits to shift, output */
        bignum_shift_left(out, 8, out);
        be_input_length--;
        out->le_words[0] |= be_input;
        /* BUG: words_counter incremented without any check */
        out->words_counter++;
        be_input++;
    }
    /* Remove leading zeroes */
    while (out->words_counter && (out->le_words[out->words_counter] == 0))
    {
        out->words_counter--;
    }
    if (out->words_counter == 0)
    {
        out->negative = 0;
    }
}
```

When shifting 8 bits left, `bignum_shift_left()` function will:
  * move the bytes towards increasing addresses (little endian)
  * increment `words_counter` if needed but if and only if the value is lower than 132
  * remove leading zeroes (if any)

The `bignum_shift_left()` function assumes that incoming `words_counter` is within range and thus it will move
data past the `le_words[]` array if `words_counter` is greater than 132.

Exploitation
------------

The attacker has full control over the RFC4880 signature and thus can indicate MPI data length up to 65535 bits.

The fact that `words_counter` is after the `le_words[]` array severely limits actual attack possibilities.
The `words_counter` value will quickly grow to enormous values when MPI length is too big. For example when loading
526 byte long MPI, `words_counter` will be `0x00008501`, for 527 byte MPI it will be `0x00850101` and for 528 or
larger it will be `0x80EF03FD`. Such big values not only makes the execution very slow, but also result in device
accessing addresses outside RAM region (`0x01000000` to `0x04FFFFFF`). It is worth noticing that the value in case
for 528 or larger is not `0x85010101`. This is due to the leading zeroes removal as it turns out that quite many
of the unmapped addresses actually read out as zero. For larger values the loading does not even complete as the
system state is severly corrupted.

The signature verification function resembles following pseudocode (in order to simplify the explanation following
code only shares the overall idea and otherwise differs from the actual function):
```
int verify_component(void *rfc4880_sig, bignum_t *modulus, binum_t *exponent)
{
    /* signature is the last local variable on the stack */
    bignum_t signature;

    if (!parse_pgp_signature(rfc4880_sig, &signature))
    {
        /* Calculate checksum and check if the checksum matches lowest significant
         * bytes of RSA signature (signature ** exponent mod modulus) completely
         * ignoring padding.
         */
        if (verified)
        {
            return 1;
        }
    }
    return 0;
}
```

From the above pseudocode we can observe that signature is on stack and thus it is possible to alter the return
address by supplying specifically crafted signature. The first instruction in actual `verify_component()` function is:
`stmdb sp!, {r4 r5 r6 r7 r8 r9 r10 r11 lr}`. When this function is called, `r4` holds public key index which is always
1 on production devices (on development devices the value in first call is 2, then 1).

During signature verification on bootloader version 24655 the `words_counter` value is at address `0x143F21C`.
When validating genuine signatures the interesting memory location values are:
```
0x143F21C:      0x40    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x143F224:      0x01    0x00    0x00    0x00    0x48    0xF2    0x43    0x01
0x143F22C:      0x60    0xF4    0x43    0x01    0x04    0xCF    0x30    0x01
0x143F234:      0x0F    0x79    0xFF    0xF5    0xDF    0x97    0x77    0x6F
0x143F23C:      0xEE    0xE6    0xEE    0x81    0x2E    0x7F    0xED    0xEF
0x143F244:      0x54    0x1E    0x30    0x01
```

The stored `r4` register value is `0x00000001` at address `0x143F224` and return address is `0x01301E54`.
When the supplied MPI length is 527 or 528 bytes, the stored return address can be modified to either
`0x301E54EF` or `0x1E54EFED`. These addresses are outside of RAM and as such will simply lead to crash.

In order to successfully exploit the vulnerability, the modified return address would have to be in attacker controlled
memory regions. In above memory dump, the possibilities would be `0x040143F4` and `0x01000000`. Note that `0x040143F4`
is dependent on the actual bootloader build and thus the value `0x01000000` is desired.

To shift the bytes more than 2 places up, the `words_counter` value needs to be prevented from growing.
The stack region is `0x1420000` to `0x143FFFF`. Uninitialized bytes in RAM default to `0xFF`.
To prevent `words_counter` from growing, the RAM starting at `0x1440000` needs to be zeroed out.
When the memory is zeroed out the leading zeroes removal will significantly reduce `words_counter` value.
If MPI length is large enough the `words_counter` will jump from `0x00000084` to `0x00000085`, then to `0x000003FE`,
then to `0x000003FF` and will continue to grow by 1 every 4 loaded MPI bytes. In order to get the return address value
`0x01000000`, the supplied MPI length must be between 4481 and 4488 bits. It is possible to supply such length by the attacker
because 4488 is lower than 65535.

Attacker can zero out enough bytes of memory starting at `0x1440000` by setting one of the firmware images load address
to `0x1440000`. The other firmware image load address must be set to `0x01000000` as the device will execute code
at that location after exploitation. The crafted signature must be included in kernel image as it is the first one that
is being verified (device enters Recovery Mode if kernel signature verification fails).

The `zsitool` exploit option uses initrd as the zero fill and kernel for the actual payload. This is because the expected
payload (Rockbox bootloader) is much smaller than required amounts of zero fill. This minimizes the time taken by checksum
calculation (when exploited, initrd checksum is not being computed at all) and thus reduces the boot time.
